import sys
import json
import re
import os

from autoparallel.BE.SlotRouting import addAllAnchors, removePlaceholderAnchors
from autoparallel.BE.Utilities import getSlotsInSLRIndex, loggingSetup

loggingSetup()

SLR_NUM = 4


def placeBackSourceCellofLagunaAnchors(slr_index):
  """
  if the source cells of laguna anchors are placed at TX lagunas
  their placement will be lost due to limitation of the RW stitcher
  Therefore we need to manually place them back
  """
  script = []
  if hub["InSlotPipelineStyle"] == 'INVERT_CLOCK':
    slots = getSlotsInSLRIndex(hub, slr_index)
    for pair in hub["AllSlotPairs"]:
      if (pair[0] in slots) != (pair[1] in slots):
        pair_name = '_AND_'.join(pair)
        script.append(f'source {anchor_placement_dir}/{pair_name}/{anchor_source_placement_script}')
  
  return script


def getVivadoScriptForSLR(slr_index):

  script = []

  # this will be generated by RW after the stitching
  script.append(f'source -notrace {slr_stitch_dir}/slr_{slr_index}/slr_{slr_index}_load.tcl')

  # place back the missing laguna anchor sources
  script += placeBackSourceCellofLagunaAnchors(slr_index)
  
  # to verify the tap of row buffers
  script.append(f'puts [get_property ROUTE [get_nets ap_clk]]')
  script.append(f'report_timing_summary')

  script.append(f'delete_pblocks *')

  # unroute the laguna nets that cause conflict
  script.append(f'set_property ROUTE "" [get_nets -hierarchical -filter {{ ROUTE_STATUS == "CONFLICTS" }}]')

  # relax the clock 
  script.append(f'create_clock -name ap_clk -period 3 [get_pins test_bufg/O]')
  script.append(f'set_clock_uncertainty -hold 0.02 [get_clocks ap_clk]')

  script.append(f'write_checkpoint slr_{slr_index}_before_routed.dcp')

  # add back the placeholder FFs
  script += addAllAnchors(hub, base_dir, getSlotsInSLRIndex(hub, slr_index))

  script.append(f'route_design -preserve')

  # remove the placeholder anchors
  script += removePlaceholderAnchors()

  script.append(f'write_checkpoint {slr_stitch_dir}/slr_{slr_index}/checkpoint/slr_{slr_index}_routed.dcp')
  script.append(f'write_edif {slr_stitch_dir}/slr_{slr_index}/checkpoint/slr_{slr_index}_routed.edf')

  return script


def getParallelTasks():
  all_tasks = []
  for slr_index in range(SLR_NUM):
    slots = getSlotsInSLRIndex(hub, slr_index)

    cd = f'cd {slr_stitch_dir}/slr_{slr_index}'
    rw_source = f'source {RW_SETUP_PATH}'
    get_dcp_regexp = lambda slot_name: f'(.*{slot_name}.*phys_opt.*dcp)'
    all_dcp_regexps = '|'.join([get_dcp_regexp(slot_name) for slot_name in slots])
    rw = f'java com.xilinx.rapidwright.examples.MergeDCP {slot_routing_dir} slr_{slr_index}.dcp "{all_dcp_regexps}"'

    vivado = f'VIV_VER={VIV_VER} vivado -mode batch -source {slr_stitch_dir}/slr_{slr_index}/route_slr_{slr_index}.tcl'

    stitch = f'{cd} && {rw_source} && {rw} && {vivado}'

    all_tasks.append(stitch)

  open(f'{slr_stitch_dir}/parallel-route-slr.txt', 'w').write('\n'.join(all_tasks))


if __name__ == '__main__':
  assert len(sys.argv) == 5, 'input (1) the path to the front end result file and (2) the target directory'
  hub_path = sys.argv[1]
  base_dir = sys.argv[2]
  VIV_VER=sys.argv[3]
  RW_SETUP_PATH = sys.argv[4]

  hub = json.loads(open(hub_path, 'r').read())

  slr_stitch_dir = f'{base_dir}/SLR_level_stitch'
  os.mkdir(slr_stitch_dir)

  slot_routing_dir = f'{base_dir}/slot_routing'

  anchor_placement_dir = f'{base_dir}/ILP_anchor_placement_iter0'
  anchor_source_placement_script = 'place_laguna_anchor_source_cells.tcl'

  for slr_index in range(SLR_NUM):
    os.mkdir(f'{slr_stitch_dir}/slr_{slr_index}')
    os.mkdir(f'{slr_stitch_dir}/slr_{slr_index}/checkpoint')

  for slr_index in range(SLR_NUM):
    script = getVivadoScriptForSLR(slr_index)

    open(f'{slr_stitch_dir}/slr_{slr_index}/route_slr_{slr_index}.tcl', 'w').write('\n'.join(script))

  getParallelTasks()